<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ØªØ®Ù… Ø§Ú˜Ø¯Ù‡Ø§ - Ø­Ù…Ù„Ù‡ Ù…Ø§Ø±Ù‡Ø§</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle, #1e1e2f, #101022);
      font-family: 'Tahoma', sans-serif;
    }
    /* Ø¸Ø±Ù Ø¹Ù„Ø§Ù…Øª Ø¯Ù„Ø§Ø± */
    #dollar-container {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .dollar {
      position: absolute;
      color: gold;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 5px gold;
      animation: moveUp 1s forwards;
    }
    @keyframes moveUp {
      from { opacity: 1; transform: translateY(0px); }
      to { opacity: 0; transform: translateY(-100px); }
    }
    /* Ú©Ù†ØªØ±Ù„ ØµØ¯Ø§ */
    #sound-control {
      position: absolute;
      top: 20px;
      right: 20px;
      cursor: pointer;
      z-index: 10;
    }
    #sound-control img {
      width: 30px;
      height: 30px;
    }
    #progress-bar-container {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 50%;
      height: 20px;
      background-color: #333;
      border-radius: 10px;
      overflow: hidden;
      z-index: 10;
    }
    #progress-bar {
      height: 100%;
      width: 0%;
      background-color: #4caf50;
      transition: width 0.3s ease;
    }
    /* Ù†Ù…Ø§ÛŒØ´ Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§ */
    #score-container {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      font-size: 20px;
      color: white;
      z-index: 10;
    }
    #positive-score {
      color: green;
    }
    #negative-score {
      color: red;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
</head>
<body>
  <div id="progress-bar-container">
    <div id="progress-bar"></div>
  </div>
  <div id="score-container">
    <div id="positive-score">Ø§Ù…ØªÛŒØ§Ø² Ù…Ø«Ø¨Øª: 0</div>
    <div id="negative-score">Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†ÙÛŒ: 0</div>
  </div>
  <div id="dollar-container"></div>
  <div id="sound-control" onclick="toggleSound()"> 
    <div id="sound-icon">ğŸ”‡</div>
  </div>
  <!-- Ù…ÙˆØ³ÛŒÙ‚ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ ØªØ±Ø³Ù†Ø§Ú© (Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø² Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù…Ù†Ø¨Ø¹ ØµÙˆØªÛŒ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯) -->
  <audio id="bg-audio" loop autoplay>
    <source src="snakeecho-78798.mp3" type="audio/mp3">
    Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø§Ø² Ø§ÛŒÙ† ÙØ±Ù…Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
  </audio>

  <!-- Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ three.js Ø§Ø² CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡ ØµØ­Ù†Ù‡
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 2000);
    camera.position.set(0, 0, 800);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Ù†ÙˆØ±Ù¾Ø±Ø¯Ø§Ø²ÛŒ
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 200);
    scene.add(directionalLight);

    // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØµÙˆÛŒØ± ØªØ®Ù… Ø§Ú˜Ø¯Ù‡Ø§
    const textureLoader = new THREE.TextureLoader();
    const eggTexture = textureLoader.load('egg-image.png'); // Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†ÛŒØ¯ Ø¨Ø§ URL ØªØµÙˆÛŒØ±
    eggTexture.wrapS = THREE.RepeatWrapping;
    eggTexture.wrapT = THREE.RepeatWrapping;
    eggTexture.minFilter = THREE.LinearMipMapLinearFilter;
    eggTexture.magFilter = THREE.LinearFilter;
    eggTexture.offset.set(-0.064, 0.17); // ØªÙ†Ø¸ÛŒÙ… Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§ÙØª
    eggTexture.repeat.set(1, 1); // ØªÙ†Ø¸ÛŒÙ… Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ø§ÙØª

    const eggGeometry = new THREE.SphereGeometry(30, 32, 32);
    eggGeometry.scale(1.6, 2.3, 15.2);
    const eggMaterial = new THREE.MeshPhongMaterial({
      map: eggTexture,
      transparent: true,
      side: THREE.DoubleSide
    });
    const egg = new THREE.Mesh(eggGeometry, eggMaterial);
    egg.position.set(0, 0, 0);
    scene.add(egg);

    const gui = new dat.GUI();
    const eggFolder = gui.addFolder("Dragon Egg");
    eggFolder.add(egg.scale, "x", 0.5, 2).name("Scale X");
    eggFolder.add(egg.scale, "y", 0.5, 2).name("Scale Y");
    eggFolder.add(egg.scale, "z", 0.5, 20).name("Scale Z");
    eggFolder.add(eggTexture.offset, "x", -1.0, 1.0).name("offset X");
    eggFolder.add(eggTexture.offset, "y", 0.00, 1.0).name("offset Y");
    eggFolder.add(eggTexture.repeat, "x", 1, 100).name("repeat X");
    eggFolder.add(eggTexture.repeat, "y", 1, 100).name("repeat Y");
    eggFolder.open();

    // Ø¢Ø±Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±Ù†Ø¯Ù‡ Ù…Ø§Ø±Ù‡Ø§
    let snakes = [];
    let dyingSnakes = [];
    const targetSnakeCount = 10; // ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ø±Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± ØµÙØ­Ù‡
    const maxSnakeCount = 100; // Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ø±Ù‡Ø§
    let snakesKilled = 0; // ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø­Ø°Ùâ€ŒØ´Ø¯Ù‡
    let positiveScore = 0; // Ø§Ù…ØªÛŒØ§Ø² Ù…Ø«Ø¨Øª
    let negativeScore = 0; // Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†ÙÛŒ
    const clock = new THREE.Clock();

    // ØªØ§Ø¨Ø¹ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§
    function updateScores() {
      document.getElementById('positive-score').textContent = `Ø§Ù…ØªÛŒØ§Ø² Ù…Ø«Ø¨Øª: ${positiveScore}`;
      document.getElementById('negative-score').textContent = `Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†ÙÛŒ: ${negativeScore}`;
    }

    // ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø¹Ø¯Ø¯ ØªØµØ§Ø¯ÙÛŒ
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    // ØªØ§Ø¨Ø¹ Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ø§ÙØª Ù…Ø§Ø± Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² canvas (Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø®Ø§Ù„ Ùˆ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ ØªØ±Ø³Ù†Ø§Ú©)
    function createSnakeTexture(baseColor, spotColor) {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¨Ø§ Ø±Ù†Ú¯ Ù¾Ø§ÛŒÙ‡
      ctx.fillStyle = baseColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Ø±Ø³Ù… Ø®Ø§Ù„â€ŒÙ‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ
      for (let i = 0; i < 10; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const radius = Math.random() * 10 + 5;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = spotColor;
        ctx.fill();
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    // ØªØ§Ø¨Ø¹ Ø§ÛŒØ¬Ø§Ø¯ Ù…Ù†Ø­Ù†ÛŒ Ù…Ø§Ø± Ø¨Ø§ Ø§ÙÚ©Øª Ù†ÙˆØ³Ø§Ù†ÛŒ
    function createSnakeCurve(snake, currentTime) {
      const head = new THREE.Vector3().lerpVectors(snake.start, egg.position, snake.progress);
      const dir = new THREE.Vector3().subVectors(egg.position, snake.start).normalize();
      const perp = new THREE.Vector3(-dir.y, dir.x, 0);
      const curve = new THREE.Curve();
      curve.getPoint = function(t) {
        const base = new THREE.Vector3().lerpVectors(snake.start, head, t);
        // Ø§ÙÚ©Øª Ù†ÙˆØ³Ø§Ù†ÛŒ Ú©Ù‡ Ù†Ø²Ø¯ÛŒÚ©ÛŒ Ø¨Ù‡ Ø³Ø± Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
        const offset = Math.sin(t * snake.frequency * Math.PI * 2 + snake.phase + currentTime) * snake.amplitude * (1 - t);
        base.addScaledVector(perp, offset);
        return base;
      };
      curve.getTangent = function(t) {
        const delta = 0.0001;
        const p1 = curve.getPoint(t);
        const p2 = curve.getPoint(Math.min(t + delta, 1));
        return p2.sub(p1).normalize();
      };
      return curve;
    }

    // ØªØ§Ø¨Ø¹ Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø± Ù…Ø§Ø± Ø¨Ù‡ Ø´Ú©Ù„ Ú©Ø¨Ø±ÛŒ Ø¨Ø§ Ù†ÛŒØ´â€ŒÙ‡Ø§ÛŒ Ù…Ø´Ø®Øµ
    function createSnakeHead() {
      const headGroup = new THREE.Group();
      // Ø³Ø± Ù…Ø§Ø± (Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÛŒÚ© Ú©Ø±Ù‡â€ŒÛŒ Ú©ÙˆÚ†Ú© Ú©Ù‡ Ú©Ù…ÛŒ ÙÙÙ„ÙØª Ø´Ø¯Ù‡)
      const headGeometry = new THREE.SphereGeometry(8, 16, 16);
      const headMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true, transparent: true, opacity: 1 });
      const headMesh = new THREE.Mesh(headGeometry, headMaterial);
      headMesh.scale.set(1.5, 1, 1); // Ø§ÛŒØ¬Ø§Ø¯ Ø´Ú©Ù„ Ú©Ø¨Ø±ÛŒ
      headGroup.add(headMesh);
      // Ù†ÛŒØ´â€ŒÙ‡Ø§ (Ø¯Ùˆ Ù…Ø®Ø±ÙˆØ· Ú©ÙˆÚ†Ú©)
      const fangGeometry = new THREE.ConeGeometry(1.5, 4, 8);
      const fangMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
      const leftFang = new THREE.Mesh(fangGeometry, fangMaterial);
      const rightFang = new THREE.Mesh(fangGeometry, fangMaterial);
      leftFang.position.set(-2, 0, 8);
      rightFang.position.set(2, 0, 8);
      leftFang.rotation.x = Math.PI / 2;
      rightFang.rotation.x = Math.PI / 2;
      headGroup.add(leftFang);
      headGroup.add(rightFang);
      return headGroup;
    }

    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‡Ù†Ø¯Ø³Ù‡ Ù…Ø§Ø± (Ø¨Ø¯Ù† Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø³Ø±)
    function updateSnakeGeometry(snake, currentTime) {
      const curve = createSnakeCurve(snake, currentTime);
      const newGeometry = new THREE.TubeGeometry(curve, 20, 5, 8, false);
      snake.bodyMesh.geometry.dispose();
      snake.bodyMesh.geometry = newGeometry;
      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø³Ø±: Ú¯Ø±ÙØªÙ† Ø¢Ø®Ø±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù…Ù†Ø­Ù†ÛŒ
      const headPosition = curve.getPoint(1);
      snake.headGroup.position.copy(headPosition);
      // ØªÙ†Ø¸ÛŒÙ… Ø¬Ù‡Øª Ø³Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ§Ù†Ú˜Ø§Ù†Øª Ù…Ù†Ø­Ù†ÛŒ
      const tangent = curve.getTangent(1);
      const angle = Math.atan2(tangent.y, tangent.x);
      snake.headGroup.rotation.z = angle;
    }

    // Ø§ÛŒØ¬Ø§Ø¯ ÛŒÚ© Ù…Ø§Ø± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ø¨Ø¯Ù† Ùˆ Ø³Ø± Ù…Ø´Ø®Øµ
    function createSnake() {
      const angle = rand(0, Math.PI * 2);
      const radius = rand(400, 600);
      const start = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
      const snake = {
        start: start,
        progress: 0,
        speed: rand(0.1, 0.3),
        amplitude: rand(10, 30),
        frequency: rand(2, 4),
        phase: rand(0, Math.PI * 2),
        dying: false,
        pauseTime: 0 // Ø²Ù…Ø§Ù† Ù…Ú©Ø« Ø±ÙˆÛŒ ØªØ®Ù…
      };
      const curve = createSnakeCurve(snake, 0);
      const geometry = new THREE.TubeGeometry(curve, 20, 5, 8, false);
      // Ø§Ù†ØªØ®Ø§Ø¨ ØªØµØ§Ø¯ÙÛŒ Ø±Ù†Ú¯â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø¯Ù†
      const baseColors = ['#3a5f0b', '#5a2d0b', '#2b3a5f'];
      const spotColors = ['#1a2f07', '#3a1f07', '#1a1a2f'];
      const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];
      const spotColor = spotColors[Math.floor(Math.random() * spotColors.length)];
      const texture = createSnakeTexture(baseColor, spotColor);
      const material = new THREE.MeshPhongMaterial({ map: texture, transparent: true, opacity: 1 });
      const bodyMesh = new THREE.Mesh(geometry, material);
      snake.bodyMesh = bodyMesh;
      const headGroup = createSnakeHead();
      snake.headGroup = headGroup;
      const snakeGroup = new THREE.Group();
      snakeGroup.add(bodyMesh);
      snakeGroup.add(headGroup);
      snake.group = snakeGroup;
      scene.add(snakeGroup);
      snakes.push(snake);
    }

    // ÙˆØ§Ú©Ù†Ø´ Ø¨Ù‡ ØªØºÛŒÛŒØ± Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾Ù†Ø¬Ø±Ù‡
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙˆÙ„ÛŒÙ‡ Ù…Ø§Ø±Ù‡Ø§
    for (let i = 0; i < targetSnakeCount; i++) {
      createSnake();
    }

    // Ø­Ù„Ù‚Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù†
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const currentTime = performance.now() / 1000;

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø±Ú©Øª
      for (let i = snakes.length - 1; i >= 0; i--) {
        const snake = snakes[i];
        if (!snake.dying) {
          if (snake.progress >= 1) {
            // Ù…Ø§Ø± Ø¨Ù‡ ØªØ®Ù… Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª
            if (snake.pauseTime === 0) {
              snake.pauseTime = currentTime; // Ø²Ù…Ø§Ù† Ø´Ø±ÙˆØ¹ Ù…Ú©Ø«
            } else if (currentTime - snake.pauseTime > 3) {
              // Ø§Ú¯Ø± Ø¨ÛŒØ´ Ø§Ø² Û³ Ø«Ø§Ù†ÛŒÙ‡ Ù…Ú©Ø« Ú©Ø±Ø¯ØŒ Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†ÙÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
              negativeScore++;
              updateScores();
              snake.dying = true;
              snake.dissolveStart = currentTime;
              snake.dissolveDuration = 0.5;
              dyingSnakes.push(snake);
              snakes.splice(i, 1);
            }
          } else {
            snake.progress = Math.min(snake.progress + snake.speed * delta, 1);
            updateSnakeGeometry(snake, currentTime);
          }
        }
      }

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¯Ø± Ø­Ø§Ù„Øª Ø¯ÙˆØ¯ Ø´Ø¯Ù† Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯
      for (let i = dyingSnakes.length - 1; i >= 0; i--) {
        const snake = dyingSnakes[i];
        const elapsed = currentTime - snake.dissolveStart;
        const duration = snake.dissolveDuration;
        const newOpacity = 1 - (elapsed / duration);
        snake.bodyMesh.material.opacity = newOpacity;
        snake.headGroup.children.forEach(child => {
          if(child.material) {
            child.material.opacity = newOpacity;
          }
        });
        snake.group.rotation.z += delta * 5;
        updateSnakeGeometry(snake, currentTime);
        if (elapsed >= duration) {
          scene.remove(snake.group);
          dyingSnakes.splice(i, 1);
        }
      }

      // Ø¯Ø± ØµÙˆØ±Øª Ú©Ø§Ù‡Ø´ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ø±Ù‡Ø§ØŒ Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø§Ø± Ø¬Ø¯ÛŒØ¯
      if (snakes.length < targetSnakeCount && snakesKilled < maxSnakeCount) {
        createSnake();
      }

      renderer.render(scene, camera);
    }
    animate();

    // ØªØ§Ø¨Ø¹ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†ÙˆØ§Ø± Ù¾ÛŒØ´Ø±ÙØª
    function updateProgressBar(progress) {
      const progressBar = document.getElementById('progress-bar');
      progressBar.style.width = `${progress}%`;
    }

    // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙÚ©Øª Ø¹Ù„Ø§Ù…Øª Ø¯Ù„Ø§Ø± Ø¯Ø± Ù…Ø­Ù„ Ø±ÙˆÛŒØ¯Ø§Ø¯
    function showDollar(x, y) {
      const dollar = document.createElement('div');
      dollar.className = 'dollar';
      dollar.style.left = x + 'px';
      dollar.style.top = y + 'px';
      dollar.textContent = '$';
      document.getElementById('dollar-container').appendChild(dollar);
      setTimeout(() => { dollar.remove(); }, 1000);
    }

    // Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆÛŒØ¯Ø§Ø¯ Ú©Ù„ÛŒÚ© ÛŒØ§ ØªØ§Ú†: Ø­Ø°Ù ÛŒÚ© Ù…Ø§Ø± (Ø¨Ø§ Ø§ÙÚ©Øª Ø¯ÙˆØ¯ Ø´Ø¯Ù†) Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø¹Ù„Ø§Ù…Øª Ø¯Ù„Ø§Ø±
    function handleClick(event) {
      let x, y;
      if (event.touches && event.touches.length) {
        x = event.touches[0].clientX;
        y = event.touches[0].clientY;
      } else {
        x = event.clientX;
        y = event.clientY;
      }
      showDollar(x, y);
      if (snakes.length > 0) {
        const snake = snakes.shift();
        snake.dying = true;
        snake.dissolveStart = performance.now() / 1000;
        snake.dissolveDuration = 0.5;
        dyingSnakes.push(snake);

        // Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø­Ø°Ùâ€ŒØ´Ø¯Ù‡ Ùˆ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†ÙˆØ§Ø± Ù¾ÛŒØ´Ø±ÙØª
        snakesKilled++;
        positiveScore++; // Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù…ØªÛŒØ§Ø² Ù…Ø«Ø¨Øª
        updateScores();
        const progress = (snakesKilled / maxSnakeCount) * 100;
        updateProgressBar(progress);
      }
    }
    window.addEventListener('click', handleClick);
    window.addEventListener('touchstart', (e) => { handleClick(e); });

    // ØªØ§Ø¨Ø¹ Ú©Ù†ØªØ±Ù„ ØµØ¯Ø§: Ù‚Ø·Ø¹ Ùˆ ÙˆØµÙ„ Ù…ÙˆØ³ÛŒÙ‚ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
    function toggleSound() {
      const audio = document.getElementById('bg-audio');
      const icon = document.getElementById('sound-icon');
      if (audio.paused) {
        audio.play();
        icon.textContent = "ğŸ”ˆ";
      } else {
        audio.pause();
        icon.textContent = "ğŸ”‡";
      }
    }
  </script>
</body>
</html>